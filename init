#!/bin/bash
#
# Licensed under the GPLv2
#
# Copyright 2008, Red Hat, Inc.
# Jeremy Katz <katzj@redhat.com>

emergency_shell()
{
    echo ; echo
    echo "Bug in initramfs /init detected. Dropping to a shell. Good luck!"
    echo
    bash < /dev/console
}

getarg() {
    for o in $(< /proc/cmdline); do
	[[ $o == $1 ]] && { echo $o; break; }
    done
}

echo "Starting initrd..."
export PATH=/sbin:/bin:/usr/sbin:/usr/bin
export TERM=linux

trap "emergency_shell" 0 2
# /dev/console comes from the built-in initramfs crud in the kernel
# someday, we may need to mkdir /dev first here
exec > /dev/console 2>&1 < /dev/console

# mount some important things
mount -t proc /proc /proc
mount -t sysfs /sys /sys
mount -t tmpfs -omode=0755 udev /dev

# FIXME: what device nodes does plymouth really _need_ ?
mknod /dev/ptmx c 5 2
mknod /dev/console c 5 0
mknod /dev/fb c 29 0
mkdir /dev/pts
mount -t devpts -o gid=5,mode=620 /dev/pts /dev/pts
mknod /dev/tty0 c 4 0
mknod /dev/tty1 c 4 1
mknod /dev/null c 1 3

# start up udev and trigger cold plugs
udevd --daemon
udevadm trigger >/dev/null 2>&1

# mount the rootfs
NEWROOT="/sysroot"

# FIXME: there's got to be a better way ...
# it'd be nice if we had a udev rule that just did all of the bits for
# figuring out what the specified root is and linking it /dev/root
root=$(getarg 'root=*'); root=${root#root=}
case $root in
    LABEL=*) root=${root#LABEL=}
             root=${root//\//\\x2f}
	     root="/dev/disk/by-label/${root}" ;;
    UUID=*) root="/dev/disk/by-uuid/${root#UUID=}" ;;
    '') echo "Warning: no root specified"
	root="/dev/sda1" ;;
esac

# should we have a timeout?
tries=0
echo "Waiting up to 30 seconds for $root to become available"
udevadm settle --timeout=30
[[ -f /cryptroot ]] && {
    echo "Encrypted root detected."
    cryptopts=$(< /cryptroot)
    /sbin/cryptsetup luksOpen $cryptopts || emergency_shell
    udevadm settle --timeout=30
}
echo "Trying to mount rootfs $root"
[[ -e $root ]] || emergency_shell
ln -s "$root" /dev/root    
mount -o ro /dev/root $NEWROOT || emergency_shell

# now we need to prepare to switchroot
mount --bind /dev $NEWROOT/dev

# FIXME: now for a bunch of boiler-plate mounts.  really, we should have 
# some like /etc/fstab.sys that's provided by filesystem/initscripts
# and then do mount -f /etc/fstab.sys -a
mount -t proc /proc $NEWROOT/proc
mount -t sysfs /sys $NEWROOT/sys

# FIXME: load selinux policy.  this should really be done after we switchroot 
if [ -x $NEWROOT/usr/sbin/load_policy ]; then
  chroot $NEWROOT /usr/sbin/load_policy -i
  if (($? == 3)); then
    echo "Initial SELinux policy load failed and enforcing mode requested."
    echo "Not continuing"
    sleep 100d
    exit 1
  fi
fi

# kill off udev
kill $(pidof udevd)

# FIXME: nash die die die
exec switch_root
# davej doesn't like initrd bugs
echo "Something went very badly wrong in the initrd.  Please "
echo "file a bug against mkinitrd."
sleep 100d
exit 1
