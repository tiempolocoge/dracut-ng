#!/bin/sh
#
# Licensed under the GPLv2
#
# Copyright 2008, Red Hat, Inc.
# Jeremy Katz <katzj@redhat.com>

emergency_shell()
{
    echo ; echo
    echo "Bug in initramfs /init detected. Dropping to a shell. Good luck!"
    echo
    sh -i
}

getarg() {
    local o line
    for o in $CMDLINE; do
	[ "${o%%=*}" = "$1" ] && { echo $o; return 0; }
    done
    return 1
}

source_all() {
    local f
    [ "$1" ] && [  -d "/$1" ] || return
    for f in "/$1"/*.sh; do [ -f "$f" ] && . "$f"; done
}

echo "Starting initrd..."
export PATH=/sbin:/bin:/usr/sbin:/usr/bin
export TERM=linux
CONSOLE=/dev/console
[ -c $CONSOLE ] && exec >$CONSOLE 2>&1 <$CONSOLE
trap "emergency_shell" 0
# mount some important things
mount -t proc /proc /proc
mount -t sysfs /sys /sys
mount -t tmpfs -omode=0755 udev /dev
read CMDLINE </proc/cmdline;


# FIXME: what device nodes does plymouth really _need_ ?
mknod /dev/ptmx c 5 2
mknod /dev/console c 5 0
mknod /dev/fb c 29 0
mkdir /dev/pts
mount -t devpts -o gid=5,mode=620 /dev/pts /dev/pts
mknod /dev/tty0 c 4 0
mknod /dev/tty1 c 4 1
mknod /dev/null c 1 3

source_all pre-udev

# start up udev and trigger cold plugs
udevd --daemon
udevadm trigger >/dev/null 2>&1

# mount the rootfs
NEWROOT="/sysroot"

# FIXME: there's got to be a better way ...
# it'd be nice if we had a udev rule that just did all of the bits for
# figuring out what the specified root is and linking it /dev/root
root=$(getarg root); root=${root#root=}
case $root in
    LABEL=*) root=${root#LABEL=}
             root="$(echo $root |sed 's,/,\\x2f,g')"
	     root="/dev/disk/by-label/${root}" ;;
    UUID=*) root="/dev/disk/by-uuid/${root#UUID=}" ;;
    '') echo "Warning: no root specified"
	root="/dev/sda1" ;;
esac

# should we have a timeout?
tries=0
echo "Waiting up to 30 seconds for $root to become available"
udevadm settle --timeout=30
source_all pre-mount

echo "Trying to mount rootfs $root"
if rflags="$(getarg rootflags)"; then
    rflags="${rflags#rootflags=}"
    getarg rw >/dev/null && rflags="${rflags},rw" || rflags="${rflags},ro"
else
     getarg rw >/dev/null && rflags=rw || rflags=ro
fi
[ -e "$root" ] || emergency_shell
ln -s "$root" /dev/root 
fstype="$(getarg rootfstype)" && fstype="-t ${fstype#rootfstype=}" 
mount $fstype -o $rflags /dev/root $NEWROOT || emergency_shell

INIT=$(getarg init); INIT=${INIT#init=}
[ "$INIT" ] || {
    for i in /sbin/init /etc/init /init /bin/sh; do
	[ -x "$NEWROOT$i" ] && { INIT="$i"; break; }
    done
    [ "$INIT" ] || {
	echo "Cannot find init! Please check to make sure you passed"
	echo "a valid root filesystem!  Dropping to a shell."
	emergency_shell
    }
}
	    
source_all pre-pivot
echo "Switching to real root filesystem $root"
exec switch_root "$NEWROOT" "$INIT"  $CMDLINE || {
    # davej doesn't like initrd bugs
    echo "Something went very badly wrong in the initrd.  Please "
    echo "file a bug against mkinitrd."
    emergency_shell
}
