#!/bin/bash
#
# Licensed under the GPLv2
#
# Copyright 2008, Red Hat, Inc.
# Jeremy Katz <katzj@redhat.com>

emergency_shell()
{
    [ -x /bin/plymouth ] && /bin/plymouth --hide-splash
    echo ; echo
    echo "Bug in initramfs /init detected. Dropping to a shell. Good luck!"
    echo
    bash < /dev/console
}
trap "emergency_shell" 0 2

echo "Starting initrd..."
export PATH=/sbin:/bin:/usr/sbin:/usr/bin
export TERM=linux

# /dev/console comes from the built-in initramfs crud in the kernel
# someday, we may need to mkdir /dev first here
exec > /dev/console 2>&1 < /dev/console

# mount some important things
mount -t proc /proc /proc
mount -t sysfs /sys /sys
mount -t tmpfs -omode=0755 udev /dev

# FIXME: what device nodes does plymouth really _need_ ?
mknod /dev/null c 1 3
mknod /dev/kmsg c 1 11
mknod /dev/ptmx c 5 2
mknod /dev/fb c 29 0
mkdir /dev/pts
mount -t devpts -o gid=5,mode=620 /dev/pts /dev/pts
mkdir -m 1777 /dev/shm
ln -s /proc/self/fd /dev/fd
ln -s fd/0 /dev/stdin
ln -s fd/1 /dev/stdout
ln -s fd/2 /dev/stderr
mknod /dev/systty c 4 0
mknod /dev/tty0 c 4 0
mknod /dev/tty1 c 4 1
mknod /dev/tty2 c 4 2

# start plymouth if it's available
# arguably we need some of udev run first for fbmods and above devnodes :/
[ -x /sbin/plymouthd ] && /sbin/plymouthd --attach-to-session
[ -x /bin/plymouth ] && /bin/plymouth --show-splash


# start up udev and trigger cold plugs
/sbin/udevd --daemon
/sbin/udevadm trigger
# FIXME: should we really wait for the queue to settle or just try to 
# find the rootfs?
#/sbin/udevadm settle --timeout=30 || :

# mount the rootfs
NEWROOT="/sysroot"

# FIXME: there's got to be a better way ...
# it'd be nice if we had a udev rule that just did all of the bits for
# figuring out what the specified root is and linking it /dev/root
for o in `cat /proc/cmdline` ; do
  case $o in 
  root=*)
    root=${o#root=}
    ;;
  esac
done
echo -n "Going to mount rootfs ($root)"
if [ -z "$root" ]; then 
  echo "Warning: no root specified"
  root="/dev/sda1"
elif [ "${root#LABEL=}" != $root ]; then
  root="/dev/disk/by-label/${root#LABEL=}"
elif [ "${root#UUID=}" != $root ]; then
  root="/dev/disk/by-uuid/${root#UUID=}"
fi
# should we have a timeout?
tries=0
while [ ! -e $root ]; do
  echo -n "."
  sleep 1
  tries=$(($tries + 1))
  if [ $tries -gt 10 ]; then
      emergency_shell
  fi
done
echo -e "\n\nMounted rootfs after $tries seconds"
ln -s "$root" /dev/root    
mount -o ro -t ext3 /dev/root $NEWROOT

# now we need to prepare to switchroot
mount --bind /dev $NEWROOT/dev

# FIXME: now for a bunch of boiler-plate mounts.  really, we should have 
# some like /etc/fstab.sys that's provided by filesystem/initscripts
# and then do mount -f /etc/fstab.sys -a
mount -t proc /proc $NEWROOT/proc
mount -t sysfs /sys $NEWROOT/sys

# FIXME: load selinux policy

# kill off udev
kill `pidof udevd`

[ -x /bin/plymouth ] && /bin/plymouth --newroot=$NEWROOT
# FIXME: nash die die die
exec /sbin/switch_root
# davej doesn't like initrd bugs
echo "Something went very badly wrong in the initrd.  Please "
echo "file a bug against mkinitrd."
exit 1
