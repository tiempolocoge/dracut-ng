#!/bin/sh

PATH=$PATH:/sbin:/usr/sbin

. /lib/dracut-lib

getarg rdnetdebug && {
    exec >/tmp/ifup.$1.$$.out
    exec 2>>/tmp/ifup.$1.$$.out
    set -x
}

netif=$1

# bail immediately if the interface is already up
# or we don't need the network
[ -f "/tmp/net.$netif.up" ] && exit 0
[ ! -f /tmp/netroot.info ] && exit 0

# loopback is always handled the same way
[ "$netif" = "lo" ] && {
    ip link set lo up
    ip addr add 127.0.0.1/8 dev lo
    >/tmp/net.$netif.up
    exit 0
}

# XXX need error handling like dhclient-script

die() {
    echo $netif: "$@" 1>&2
    exit 1
}

do_static() {
    [ -n "$ip" ] || die "static: need IP address"
    [ -n "$mask" ] || {
	net=${ip%%.*}
	mask=255.0.0.0
	[ $net -ge 128 ] && mask=255.255.0.0
	[ $net -ge 192 ] && mask=255.255.255.0
    }
    ip addr add $ip/$mask dev $netif || die "static: setting IP $ip/$mask"
    [ -n "$gw" ] && {
	ip route add default via $gw dev $netif ||
	    die "static: setting default route via $gw"
    }
    ip link set $netif up 
    [ -e /tmp/hostname.set ] || {
	[ -n "$hostname" ] && mknod /tmp/hostname.set p 2>/dev/null &&
	    hostname $hostname
    }
    [ -n "$srv" ] &&
	echo "new_dhcp_server_identifier=$srv" > /tmp/dhclient.$netif.dhcpopts

    >/tmp/net.$netif.up
    echo online > /sys/class/net/$netif/uevent
}

do_dhcp() {
    for i in ip srv gw mask hostname; do
	eval '[ "$'$i'" ] && echo '$i'="$'$i'"'
    done > /tmp/dhclient.$netif.override
    [ -n "$ip" ] && echo bcast= >> /tmp/dhclient.$netif.override

    # /sbin/dhclient-script will mark the netif up and generate the online
    # event for nfsroot
    # XXX add -V vendor class and option parsing per kernel
    dhclient -1 -q -cf /sbin/dhclient.conf -pf /tmp/dhclient.$netif.pid -lf /tmp/dhclient.$netif.lease $netif
}

ip_to_var() {
    local v=${1}:
    set --
    while [ -n "$v" ]; do
	set -- "$@" "${v%%:*}"
	v=${v#*:}
    done

    unset ip srv gw mask hostname dev autoconf
    case $# in
    0)	autoconf=off ;;
    1)	autoconf=$1 ;;
    2)	dev=$1; autoconf=$2 ;;
    *)	ip=$1; srv=$2; gw=$3; mask=$4; hostname=$5; dev=$6; autoconf=$7
	case $autoconf in
	    ''|none|off) [ -n "$ip" ] && autoconf=static ;;
	esac
    esac
    [ -n "$dev" ] || dev=$netif
    [ -n "$autoconf" ] || autoconf=off
}

ip=$(getarg ip)
if [ -z "$ip" ]; then
    do_dhcp;
else
    # spin through the kernel command line, looking for ip= lines
    [ "$CMDLINE" ] || read CMDLINE </proc/cmdline;
    for p in $CMDLINE; do
	[ -n "${p%ip=*}" ] && continue
	ip_to_var ${p#ip=}
	
        # If this option isn't directed at our interface, skip it
	[ "$dev" = "$netif" ] || continue

	case $autoconf in
	    static)		 do_static ;;
	    dhcp|on|any)	 do_dhcp ;;
	    bootp|rarp|both) die "autoconfig type $autoconf is not supported" ;;
	    ''|none|off)	 ;;
	esac
	break
    done
fi
exit 0
