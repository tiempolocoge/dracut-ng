#!/bin/sh
# -*- mode: shell-script; indent-tabs-mode: nil; sh-basic-offset: 4; -*-
# ex: ts=8 sw=4 sts=4 et filetype=sh
#
# Licensed under the GPLv2
#
# Copyright 2008-2010, Red Hat, Inc.
# Harald Hoyer <harald@redhat.com>
# Jeremy Katz <katzj@redhat.com>

wait_for_loginit()
{
    if getargbool 0 rd.debug -y rdinitdebug -y rdnetdebug; then
        set +x
        echo "DRACUT_LOG_END"
        exec 0<>/dev/console 1<>/dev/console 2<>/dev/console
        # wait for loginit
        i=0
        while [ $i -lt 10 ]; do 
            if [ -e /run/initramfs/init.log.end ]; then
                j=$(jobs)
                [ -z "$j" ] && break
                [ -z "${j##*Running*}" ] || break
            fi
            sleep 0.1
            i=$(($i+1))
        done    
        [ $i -eq 10 ] && kill %1 >/dev/null 2>&1

        while pidof -x /sbin/loginit >/dev/null 2>&1; do
            for pid in $(pidof -x /sbin/loginit); do
                kill $HARD $pid >/dev/null 2>&1
            done
            HARD="-9"
        done
        set -x
    fi
    rm -f /run/initramfs/initlog.pipe /run/initramfs/init.log.end
}

emergency_shell()
{
    set +e
    if [ "$1" = "-n" ]; then
        _rdshell_name=$2
        shift 2 
    else
        _rdshell_name=dracut
    fi
    echo ; echo
    warn $@
    source_hook emergency
    echo
    wait_for_loginit
    [ -e /.die ] && exit 1
    if getargbool 1 rd.shell -y rdshell || getarg rd.break rdbreak; then
        echo "Dropping to debug shell."
        echo
        export PS1="$_rdshell_name:\${PWD}# "
        [ -e /.profile ] || echo "exec 0<>/dev/console 1<>/dev/console 2<>/dev/console" > /.profile
        sh -i -l
    else
        warn "Boot has failed. To debug this issue add \"rdshell\" to the kernel command line."
        # cause a kernel panic
        exit 1
    fi
}

OLD_PATH="$PATH"
export PATH=/sbin:/bin:/usr/sbin:/usr/bin
NEWROOT="/sysroot"

trap "emergency_shell Signal caught!" 0

RDDEBUG=""
. /lib/dracut-lib.sh

[ -c /dev/null ] || mknod -m 0666 /dev/null c 1 3

# mount some important things
mount -t proc -o nosuid,noexec,nodev /proc /proc >/dev/null 2>&1
mount -t sysfs -o nosuid,noexec,nodev /sys /sys >/dev/null 2>&1

if [ -x /lib/systemd/systemd-timestamp ]; then
    RD_TIMESTAMP=$(/lib/systemd/systemd-timestamp)
else
    read RD_TIMESTAMP _tmp < /proc/uptime
    unset _tmp
fi

if [ ! -c /dev/ptmx ]; then
    # try to mount devtmpfs
    if ! mount -t devtmpfs -o mode=0755,nosuid udev /dev >/dev/null 2>&1; then
        # if it failed fall back to normal tmpfs
        mount -t tmpfs -o mode=0755,nosuid udev /dev >/dev/null 2>&1 
        # Make some basic devices first, let udev handle the rest
        mknod -m 0666 /dev/null c 1 3
        mknod -m 0666 /dev/ptmx c 5 2
        mknod -m 0600 /dev/console c 5 1
        mknod -m 0660 /dev/kmsg c 1 11
    fi
fi

# prepare the /dev directory
ln -s /proc/self/fd /dev/fd >/dev/null 2>&1
ln -s /proc/self/fd/0 /dev/stdin >/dev/null 2>&1
ln -s /proc/self/fd/1 /dev/stdout >/dev/null 2>&1
ln -s /proc/self/fd/2 /dev/stderr >/dev/null 2>&1
mkdir -m 0755 /dev/shm /dev/pts /run 
mount -t devpts -o gid=5,mode=620,noexec,nosuid devpts /dev/pts >/dev/null 2>&1
mount -t tmpfs -o mode=1777,nosuid,nodev  tmpfs /dev/shm >/dev/null 2>&1
# create /run which will obsolete /var/run
mount -t tmpfs -o mode=0755,nodev,noexec,nosuid tmpfs /run >/dev/null 2>&1

mkdir -m 0755 /run/initramfs

UDEVVERSION=$(udevadm --version)
if [ $UDEVVERSION -gt 166 ]; then
    # newer versions of udev use /run/udev/rules.d
    mkdir -m 0755 /run/udev /run/udev/rules.d  
    export UDEVRULESD=/run/udev/rules.d
else
    mkdir -m 0755 /dev/.udev /dev/.udev/rules.d  
    export UDEVRULESD=/dev/.udev/rules.d
fi

[ -e /var/run ] &&  mv /var/run /var/run.bak
[ -e /var/lock ] &&  mv /var/lock /var/lock.bak
ln -fs /run /var/run
mkdir -m 0755 /run/lock
ln -fs /run/lock /var/lock
# copy over any possible directory structure
cp -ar /var/run.bak/* /run/ 2>/dev/null
cp -ar /var/lock.bak/* /run/lock/ 2>/dev/null

if getargbool 0 rd.debug -y rdinitdebug -y rdnetdebug; then
    getarg quiet && DRACUT_QUIET="yes"
    mkfifo /run/initramfs/initlog.pipe
    /sbin/loginit $DRACUT_QUIET </run/initramfs/initlog.pipe >/dev/console 2>&1 &
    exec >/run/initramfs/initlog.pipe 2>&1
else
    exec 0<>/dev/console 1<>/dev/console 2<>/dev/console
fi

setdebug

source_conf /etc/conf.d

# run scriptlets to parse the command line
getarg 'rd.break=cmdline' 'rdbreak=cmdline' && emergency_shell -n cmdline "Break before cmdline"
source_hook cmdline

[ -z "$root" ] && die "No or empty root= argument"
[ -z "$rootok" ] && die "Don't know how to handle 'root=$root'"

# Network root scripts may need updated root= options,
# so deposit them where they can see them (udev purges the env)
{
    echo "root='$root'"
    echo "rflags='$rflags'"
    echo "fstype='$fstype'"
    echo "netroot='$netroot'"
    echo "NEWROOT='$NEWROOT'"
} > /tmp/root.info

# pre-udev scripts run before udev starts, and are run only once.
getarg 'rd.break=pre-udev' 'rdbreak=pre-udev' && emergency_shell -n pre-udev "Break before pre-udev"
source_hook pre-udev

# start up udev and trigger cold plugs
udevd --daemon --resolve-names=never

UDEV_LOG_PRIO_ARG=--log-priority
UDEV_QUEUE_EMPTY="udevadm settle --timeout=0"

if [ $UDEVVERSION -lt 140 ]; then
    UDEV_LOG_PRIO_ARG=--log_priority
    UDEV_QUEUE_EMPTY="udevadm settle --timeout=1"
fi

getargbool 0 rd.udev.info -y rdudevinfo && udevadm control $UDEV_LOG_PRIO_ARG=info
getargbool 0 rd.udev.debug -y rdudevdebug && udevadm control $UDEV_LOG_PRIO_ARG=debug

getarg 'rd.break=pre-trigger' 'rdbreak=pre-trigger' && emergency_shell -n pre-trigger "Break before pre-trigger"
source_hook pre-trigger

# then the rest
udevadm trigger --action=add $udevtriggeropts  >/dev/null 2>&1

getarg 'rd.break=initqueue' 'rdbreak=initqueue' && emergency_shell -n initqueue "Break before initqueue"

RDRETRY=$(getarg rd.retry 'rd_retry=')
RDRETRY=${RDRETRY:-20}
RDRETRY=$(($RDRETRY*2))

i=0
while :; do

    check_finished && break
    
    udevsettle

    check_finished && break

    if [ -f $hookdir/initqueue/work ]; then
        rm $hookdir/initqueue/work
    fi
    
    for job in $hookdir/initqueue/*.sh; do
        [ -e "$job" ] || break
        job=$job . $job
        check_finished && break 2
    done

    $UDEV_QUEUE_EMPTY >/dev/null 2>&1 || continue

    for job in $hookdir/initqueue/settled/*.sh; do
        [ -e "$job" ] || break
        job=$job . $job
        check_finished && break 2
    done

    $UDEV_QUEUE_EMPTY >/dev/null 2>&1 || continue

    # no more udev jobs and queues empty.
    sleep 0.5

    # dirty hack for some cdrom drives,
    # which report no medium for quiet
    # some time.
    for cdrom in /sys/block/sr*; do
        [ -e "$cdrom" ] || continue 
        # skip, if cdrom medium was already found
        strstr "$(udevadm info --query=env --path=${cdrom##/sys})" \
            ID_CDROM_MEDIA && continue

        if [ -e "$cdrom"/events_poll_msecs -a -n -e "/tmp/.poll_${cdrom##*/}" ]; then
            msecs=$(while read a; do echo $a;done < "$cdrom"/events_poll_msecs)
            if [ "$msecs" = "-1" ]; then
                echo 250 > "$cdrom"/events_poll_msecs
                > "/tmp/.poll_${cdrom##*/}"
            fi
        else
            echo change > "$cdrom/uevent"
        fi
    done
    
    i=$(($i+1))
    [ $i -gt $RDRETRY ] \
        && { flock -s 9 ; emergency_shell "No root device \"$root\" found"; } 9>/.console_lock
done
unset job
unset queuetriggered

# reset cdrom polling
for cdrom in /sys/block/sr*; do
    [ -e "$cdrom" ] || continue 
    if [ -e "$cdrom"/events_poll_msecs ]; then
        echo -1 > "$cdrom"/events_poll_msecs
    fi
done

# pre-mount happens before we try to mount the root filesystem,
# and happens once.
getarg 'rd.break=pre-mount' 'rdbreak=pre-mount' && emergency_shell -n pre-mount "Break pre-mount"
source_hook pre-mount


getarg 'rd.break=mount' 'rdbreak=mount' && emergency_shell -n mount "Break mount"
# mount scripts actually try to mount the root filesystem, and may
# be sourced any number of times. As soon as one suceeds, no more are sourced.
i=0
while :; do
    [ -d "$NEWROOT/proc" ] && break;
    for f in $hookdir/mount/*.sh; do
        [ -f "$f" ] && . "$f"
        [ -d "$NEWROOT/proc" ] && break;
    done

    i=$(($i+1))
    [ $i -gt 20 ] \
        && { flock -s 9 ; emergency_shell "Can't mount root filesystem"; } 9>/.console_lock
done

{
    echo -n "Mounted root filesystem "
    while read dev mp rest; do [ "$mp" = "$NEWROOT" ] && echo $dev; done < /proc/mounts 
} | vinfo

# pre pivot scripts are sourced just before we switch over to the new root.
getarg 'rd.break=pre-pivot' 'rdbreak=pre-pivot' && emergency_shell -n pre-pivot "Break pre-pivot"
source_hook pre-pivot

# by the time we get here, the root filesystem should be mounted.
# Try to find init.
for i in "$(getarg real_init=)" "$(getarg init=)" /sbin/init /etc/init /init /bin/sh; do
    [ -n "$i" ] || continue
    if ! [ -d "$NEWROOT$i" ] && [ -L "$NEWROOT$i" -o -x "$NEWROOT$i" ]; then
        INIT="$i"
        break
    fi
done

[ "$INIT" ] || {
    echo "Cannot find init!"
    echo "Please check to make sure you passed a valid root filesystem!"
    emergency_shell
}

getarg rd.break rdbreak && emergency_shell -n switch_root "Break before switch_root"

# stop udev queue before killing it
udevadm control --stop-exec-queue

HARD=""
while pidof udevd >/dev/null 2>&1; do 
    for pid in $(pidof udevd); do
        kill $HARD $pid >/dev/null 2>&1
    done
    HARD="-9"
done

# Clean up the environment
for i in $(export -p); do
    i=${i#declare -x}
    i=${i#export}
    # skip RD_ vars
    [ "$i" != "${i#RD_}" ] && continue
    i=${i%%=*}
    [ "$i" = "root" -o "$i" = "PATH" -o "$i" = "HOME" -o "$i" = "TERM" ] || unset $i
done

initargs=""

read CLINE </proc/cmdline
if getarg init= >/dev/null ; then
    ignoreargs="console BOOT_IMAGE"
    # only pass arguments after init= to the init
    CLINE=${CLINE#*init=}
        set $CLINE
        shift
        for x in "$@"; do
            for s in $ignoreargs; do       
                [ "${x%%=*}" = $s ] && continue 2
            done
            initargs="$initargs $x"
        done
        unset CLINE
else
    set $CLINE
    shift
    for x in "$@"; do
        case "$x" in
            [0-9]|s|S|single|emergency|auto ) \
                initargs="$initargs $x"
                ;;
        esac
    done
fi

# Debug: Copy state
if getargbool 0 rd.copystate -y rdcopystate; then
    cp -axr /tmp/* /run/initramfs/ >/dev/null 2>&1
fi

if getargbool 1 rd.timestamp; then
    export RD_TIMESTAMP
else
    unset RD_TIMESTAMP
fi    

info "Switching root"

wait_for_loginit

export PATH="$OLD_PATH"

if [ -d "$NEWROOT"/run ]; then
    mount --move /run "$NEWROOT"/run
else
    if [ -e /run/initramfs ]; then
        mkdir -m 0755 /dev/.initramfs
        cp -axr /run/initramfs/* /dev/.initramfs >/dev/null 2>&1
    fi
    if [ -e /run/mdadm ]; then
        mkdir -m 0755 /dev/.mdadm
        cp -axr /run/mdadm/* /dev/.mdadm >/dev/null 2>&1
    fi
fi

if [ -f /etc/capsdrop ]; then
    . /etc/capsdrop
    info "Calling $INIT with capabilities $CAPS_INIT_DROP dropped."
    unset RD_DEBUG
    exec /usr/sbin/capsh --drop="$CAPS_INIT_DROP" -- -c "exec /sbin/switch_root \"$NEWROOT\" \"$INIT\" $initargs" || {
	warn "Command:"
	warn capsh --drop=$CAPS_INIT_DROP -- -c exec switch_root "$NEWROOT" "$INIT" $initargs
	warn "failed."
	emergency_shell
    }
else
    unset RD_DEBUG
    exec /sbin/switch_root "$NEWROOT" "$INIT" $initargs || {
	warn "Something went very badly wrong in the initramfs.  Please "
	warn "file a bug against dracut."
	emergency_shell
    }
fi
