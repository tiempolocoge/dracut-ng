#!/bin/sh
#
# Licensed under the GPLv2
#
# Copyright 2008, Red Hat, Inc.
# Jeremy Katz <katzj@redhat.com>

emergency_shell()
{
    echo ; echo
    echo "Bug in initramfs /init detected. Dropping to a shell. Good luck!"
    echo
    sh -i
}

getarg() {
    local o line
    for o in $CMDLINE; do
	[ "$o" = "$1" ] && return 0
	[ "${o%%=*}" = "${1%=}" ] && { echo ${o#*=}; return 0; }
    done
    return 1
}

source_all() {
    local f
    [ "$1" ] && [  -d "/$1" ] || return
    for f in "/$1"/*.sh; do [ -f "$f" ] && . "$f"; done
}

export PATH=/sbin:/bin:/usr/sbin:/usr/bin
export TERM=linux
NEWROOT="/sysroot"

trap "emergency_shell" 0

mknod /dev/null c 1 3

# mount some important things
mount -t proc /proc /proc >/dev/null 2>&1
mount -t sysfs /sys /sys >/dev/null 2>&1
mount -t tmpfs -omode=0755 udev /dev >/dev/null 2>&1

read CMDLINE </proc/cmdline;
getarg ramfsdebug && set -x
# Make some basic devices first, let udev handle the rest
mknod /dev/ptmx c 5 2
mknod /dev/console c 5 1
mkdir /dev/pts
mount -t devpts -o gid=5,mode=620 /dev/pts /dev/pts >/dev/null 2>&1

# pre-udev scripts run before udev starts, and are run only once.
getarg 'break=pre-udev' && emergency_shell
source_all pre-udev


[ "$root" ] || {
    root=$(getarg root=)
    case $root in
	LABEL=*) root=${root#LABEL=}
            root="$(echo $root |sed 's,/,\\x2f,g')"
            root="/dev/disk/by-label/${root}" ;;
        UUID=*) root="/dev/disk/by-uuid/${root#UUID=}" ;;
        '') echo "Warning: no root specified"
            root="/dev/sda1" ;;
    esac
}

[ "$rflags" ] || {
    if rflags="$(getarg rootflags=)"; then
	getarg rw && rflags="${rflags},rw" || rflags="${rflags},ro"
    else
	getarg rw && rflags=rw || rflags=ro
    fi
}

[ "$fstype" ] || {
    fstype="$(getarg rootfstype=)" && fstype="-t ${fstype}"
}

resume=$(getarg resume=) && ! getarg noresume && [ -b "$resume" ] && {
    # parsing the output of ls is Bad, but until there is a better way...
    (
    	echo -e 'NAME=="'${resume#/dev/}'", RUN+="/bin/sh -c \047 echo %M:%m > /sys/power/resume \047 "'
    	echo -e 'SYMLINK=="'${resume#/dev/}'", RUN+="/bin/sh -c \047 echo %M:%m > /sys/power/resume \047 "'
    ) >> /lib/udev/rules.d/99-resume.rules
}

(
 echo -e ' NAME=="'${root#/dev/}'", RUN+="/bin/sh -c \047 mount '$fstype' -o '$rflags' '$root' '$NEWROOT' \047 " '
 echo -e ' SYMLINK=="'${root#/dev/}'", RUN+="/bin/sh -c \047 mount '$fstype' -o '$rflags' '$root' '$NEWROOT' \047 " '
) >> /lib/udev/rules.d/99-mount.rules

# start up udev and trigger cold plugs
udevd --daemon
udevadm trigger >/dev/null 2>&1
udevadm settle --timeout=30 >/dev/null 2>&1

# pre-mount happens before we try to mount the root filesystem,
# and happens once.
getarg 'break=pre-mount' && emergency_shell
source_all pre-mount
getarg 'break=mount' && emergency_shell

# mount scripts actually try to mount the root filesystem, and may
# be sourced any number of times. As soon as one suceeds, no more are sourced.
i=0
while :; do
    [ -d "$NEWROOT/proc" ] && break;

    for f in /mount/*.sh; do
       [ -x "$f" ] && . "$f";
       [ "$ROOTFS_MOUNTED" ] && break;
    done

    sleep 1
    i=$(($i+1))
    (
    	flock -s 200
	[ $i -gt 10 ] && emergency_shell
    ) 200>/.console_lock
done

# pre pivot scripts are sourced just before we switch over to the new root.
getarg 'break=pre-pivot' && emergency_shell
source_all pre-pivot

# by the time we get here, the root filesystem should be mounted.
# Try to find init.
for i in "$(getarg init=)" /sbin/init /etc/init /init /bin/sh; do
    [ -f "$NEWROOT$i" -a -x "$NEWROOT$i" ] && { INIT="$i"; break; }
done
[ "$INIT" ] || {
    echo "Cannot find init! Please check to make sure you passed"
    echo "a valid root filesystem!  Dropping to a shell."
    emergency_shell
}

getarg break && emergency_shell
kill $(pidof udevd)
initargs=""
for x in "$@"; do
    [ "${x%%=*}" = "console" ] && continue
    [ "${x%%=*}" = "BOOT_IMAGE" ] && continue
    [ "${x%%=*}" = "break" ] && continue
    initargs="$initargs $x"
done
exec switch_root "$NEWROOT" "$INIT" $initargs || {
    # davej doesn't like initrd bugs
    echo "Something went very badly wrong in the initrd.  Please "
    echo "file a bug against mkinitrd."
    emergency_shell
}
